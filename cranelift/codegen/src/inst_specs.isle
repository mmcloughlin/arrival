;;;; Verification Type Models ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(model Imm64 (type (bv 64)))

; REVIEW(mbm): do we need to model MemFlags?
(model MemFlags (type
    (struct
        (aligned Bool)
        (trapcode (bv 4))
    )
))

(model Offset32 (type (bv 32)))

;;;; State Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Value loaded from memory.
;
; We deliberately do not attempt to model the entire state of memory. Modeling a
; loaded value this way allows us to express the fact that loaded values on CLIF
; and ISA side will be equivalent (combined with an assertion on address
; equality).
(state loaded_value
    (type (bv 64))
    (default true)
)

; Parameters of a CLIF load operation.
(state clif_load
    (type
        (struct
            (active Bool)
            (size_bits Int)
            (addr (bv 64))
        )
    )
    (default
        (not (:active clif_load))
    )
)

; Parameters of a CLIF store operation.
(state clif_store
    (type
        (struct
            (active Bool)
            (size_bits Int)
            (addr (bv 64))
            (value (bv 64))
        )
    )
    (default
        (and
            ; Store is not active.
            (not (:active clif_store))

            ; Must provide a fixed size in the default case, otherwise type
            ; inference is underconstrained.
            (= (:size_bits clif_store) 1)
        )
    )
)

; Whether a trap is expected according to CLIF semantics.
(state clif_trap
    (type Bool)
    (default (not clif_trap))
)

;;;; Common Term Forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(form
    bv_unary_8_to_64
    ((args (bv  8)) (ret (bv  8)))
    ((args (bv 16)) (ret (bv 16)))
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)

(form
    bv_binary_8_to_64
    ((args (bv  8) (bv  8)) (ret (bv  8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(form
    bv_ternary_8_to_64
    ((args (bv  8) (bv  8) (bv  8)) (ret (bv  8)))
    ((args (bv 16) (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64) (bv 64)) (ret (bv 64)))
)

;;;; CLIF Instruction Specifications ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Integer Instructions

(spec (iadd x y)
    (provide (= result (bvadd x y))))
(instantiate iadd
    ((args (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
    ((args (bv 128) (bv 128)) (ret (bv 128)))
)

(spec (isub x y)
    (provide (= result (bvsub x y))))
(instantiate isub bv_binary_8_to_64)

(spec (ineg x)
    (provide (= result (bvneg x))))
(instantiate ineg bv_unary_8_to_64)

(spec (iabs x)
    (provide (= result (if (bvsge x (zero_ext (widthof x) #b0)) x (bvneg x)))))
(instantiate iabs bv_unary_8_to_64)

(spec (imul x y)
    (provide (= result (bvmul x y))))
(instantiate imul bv_binary_8_to_64)

(spec (smulhi x y)
    (provide
        (let
            (
                (double (concat x x))
                (double_width (widthof double))
                (xwide (sign_ext double_width x))
                (ywide (sign_ext double_width y))
            )
            (with (low)
                (= (concat result low) (bvmul xwide ywide))
            )
        )
    )
)
(instantiate smulhi bv_binary_8_to_64)

(spec (umulhi x y)
    (provide
        (let
            (
                (double (concat x x))
                (double_width (widthof double))
                (xwide (zero_ext double_width x))
                (ywide (zero_ext double_width y))
            )
            (with (low)
                (= (concat result low) (bvmul xwide ywide))
            )
        )
    )
)
(instantiate umulhi bv_binary_8_to_64)

(spec (udiv x y)
    (modifies clif_trap)
    (provide
        (= result (bvudiv x y))
        (= clif_trap (bv_is_zero! y))
    )
)
(instantiate udiv bv_binary_8_to_64)

(spec (sdiv x y)
    (modifies clif_trap)
    (provide
        ; If j2 is 0, then the result is undefined.
        (if (bv_is_zero! y)
            clif_trap
        ; Else if j1 divided by j2 is 2^{N−1}, then the result is undefined.
        ;
        ; Note: the only way this can happen is the case (−2^{N−1})/(−1).
        (if (and
                ; x is -2^{N-1}
                (= x (bv_top_bit_set! (widthof x)))
                ; y is -1
                (bv_is_zero! (bvnot y))
            )
            clif_trap
        ; Else, return the result of dividing j1 by j2, truncated toward zero.
            (and
                (not clif_trap)
                (= result (bvsdiv x y))
            )
        ))
    )
)

(instantiate sdiv bv_binary_8_to_64)
(spec (urem x y)
    (modifies clif_trap)
    (provide
        ; If i2 is 0, then the result is undefined.
        (if (bv_is_zero! y)
            clif_trap
        ; Else, return the remainder of dividing i1 by i2.
            (and
                (not clif_trap)
                (= result (bvurem x y))
            )
        )
    )
)
(instantiate urem bv_binary_8_to_64)

(spec (srem x y)
    (modifies clif_trap)
    (provide
        ; Let j1 be the signed interpretation of i1.
        ; Let j2 be the signed interpretation of i2.
        ; If i2 is 0, then the result is undefined.
        (if (bv_is_zero! y)
            clif_trap
        ; Else, return the remainder of dividing j1 by j2, with the sign of the dividend j1.
            (and
                (not clif_trap)
                ; REVIEW(mbm): does bvsrem have the same semantics as wasm?
                (= result (bvsrem x y))

            )
        )
    )
)
(instantiate srem bv_binary_8_to_64)

(spec (iconst arg)
    (provide (= arg (zero_ext 64 result))))
(instantiate iconst
    ((args (bv 64)) (ret (bv 8)))
    ((args (bv 64)) (ret (bv 16)))
    ((args (bv 64)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
 )

(spec (ishl x y)
    (provide
        (= result
            (bvshl
                x
                (bvand y (conv_to (widthof y) (bvsub (int2bv 64 (widthof y)) #x0000000000000001)))
            )
        )
    )
)
(instantiate ishl bv_binary_8_to_64)

(spec (ushr x y)
    (provide
        (= result
            (bvlshr
                x
                (bvand y (conv_to (widthof y) (bvsub (int2bv 64 (widthof y)) #x0000000000000001)))
            )
        )
    )
)
(instantiate ushr bv_binary_8_to_64)

(spec (sshr x y)
    (provide
        (= result
            (bvashr
                x
                (bvand y (conv_to (widthof y) (bvsub (int2bv 64 (widthof y)) #x0000000000000001)))
            )
        )
    )
)
(instantiate sshr bv_binary_8_to_64)

(spec (band x y)
    (provide (= result (bvand x y))))
(instantiate band bv_binary_8_to_64)

(spec (bxor x y)
    (provide (= result (bvxor x y))))
(instantiate bxor bv_binary_8_to_64)

(spec (bor x y)
    (provide (= result (bvor x y))))
(instantiate bor bv_binary_8_to_64)

(spec (bnot x)
    (provide (= result (bvnot x))))
(instantiate bnot bv_unary_8_to_64)

(spec (rotl x y)
    (provide (= result (rotl x y))))
(instantiate rotl bv_binary_8_to_64)

(spec (rotr x y)
    (provide (= result (rotr x y))))
(instantiate rotr bv_binary_8_to_64)

(spec (bitselect c x y)
    (provide (= result (bvor (bvand c x) (bvand (bvnot c) y)))))
(instantiate bitselect bv_ternary_8_to_64)

(spec (cls x) (provide (= result (cls x))))
(instantiate cls bv_unary_8_to_64)

(spec (clz x)
    (provide (= result (clz x))))
(instantiate clz bv_unary_8_to_64)

(spec (ctz x)
    (provide (= result (clz (rev x)))))
(instantiate ctz bv_unary_8_to_64)

(spec (popcnt x)
    (provide (= result (popcnt x))))
(instantiate popcnt bv_unary_8_to_64)

(spec (load flags p offset)
    (modifies clif_load)
    (modifies loaded_value)
    (provide
        ; Activate the CLIF load effect
        (:active clif_load)

        ; TODO(mbm): load flags

        ; Load size is the width of the loaded value.
        (= (:size_bits clif_load) (widthof result))

        ; Address calculation.
        (= (:addr clif_load) (bvadd p (sign_ext 64 offset)))

        ; Result of the load is represented by low bits of the loaded value state register.
        (= result (conv_to (widthof result) loaded_value))
    )
)
(instantiate load
    ((args (named MemFlags) (named Value) (named Offset32)) (ret (bv  8)))
    ((args (named MemFlags) (named Value) (named Offset32)) (ret (bv 16)))
    ((args (named MemFlags) (named Value) (named Offset32)) (ret (bv 32)))
    ((args (named MemFlags) (named Value) (named Offset32)) (ret (bv 64)))
)
; Loads have a large number of expansions and instantiations.
(attr load (tag slow))

(spec (store flags value p offset)
    (modifies clif_store)
    (provide
        ; Activate the CLIF store effect
        (:active clif_store)

        ; TODO(mbm): store flags

        ; Store size is the width of the stored value.
        (= (:size_bits clif_store) (widthof value))

        ; Address calculation.
        (= (:addr clif_store) (bvadd p (sign_ext 64 offset)))

        ; Stored value is set to the low bits of the CLIF store value.
        (= (conv_to (widthof value) (:value clif_store)) value)

        ; HACK: Result of the store is a 1-bit vector.
        (= result #b1)
    )
)
(instantiate store
    ((args (named MemFlags) (bv 32) (named Value) (named Offset32)) (ret (bv 1)))
    ((args (named MemFlags) (bv 64) (named Value) (named Offset32)) (ret (bv 1)))
)
; Stores have a large number of expansions and instantiations.
(attr store (tag slow))

(form extend
    ((args (bv  8)) (ret (bv  8)))
    ((args (bv  8)) (ret (bv 16)))
    ((args (bv  8)) (ret (bv 32)))
    ((args (bv  8)) (ret (bv 64)))
    ((args (bv 16)) (ret (bv 16)))
    ((args (bv 16)) (ret (bv 32)))
    ((args (bv 16)) (ret (bv 64)))
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 32)) (ret (bv 64)))
    ;; Note: (bv 64) -> (bv 64) not accepted in clif
)

(spec (uextend x)
    (provide (= result (zero_ext (widthof result) x))))
(instantiate uextend extend)

(spec (sextend x)
    (provide (= result (sign_ext (widthof result) x))))
(instantiate sextend extend)

(spec (smin x y)
    (provide (= result (if (bvsle x y) x y))))
(instantiate smin bv_binary_8_to_64)

(spec (umin x y)
    (provide (= result (if (bvule x y) x y))))
(instantiate umin bv_binary_8_to_64)

(spec (smax x y)
    (provide (= result (if (bvsge x y) x y))))
(instantiate smax bv_binary_8_to_64)

(spec (umax x y)
    (provide (= result (if (bvuge x y) x y))))
(instantiate umax bv_binary_8_to_64)

(spec (icmp cc x y)
    (provide
        (= result
            (if
                (match cc
                    ((Equal) (= x y))
                    ((NotEqual) (not (= x y)))
                    ((SignedGreaterThan) (bvsgt x y))
                    ((SignedGreaterThanOrEqual) (bvsge x y))
                    ((SignedLessThan) (bvslt x y))
                    ((SignedLessThanOrEqual) (bvsle x y))
                    ((UnsignedGreaterThan) (bvugt x y))
                    ((UnsignedGreaterThanOrEqual) (bvuge x y))
                    ((UnsignedLessThan) (bvult x y))
                    ((UnsignedLessThanOrEqual) (bvule x y))
                )
                #x01
                #x00
            )
        )
    )
)
(instantiate icmp
    ((args (named IntCC) (bv  8) (bv  8)) (ret (bv 8)))
    ((args (named IntCC) (bv 16) (bv 16)) (ret (bv 8)))
    ((args (named IntCC) (bv 32) (bv 32)) (ret (bv 8)))
    ((args (named IntCC) (bv 64) (bv 64)) (ret (bv 8)))
)

;; Floating Point Instructions

; NaN Propagation: see WebAssembly Specification 2.0, section 4.3.3

; Evaluates the positive WebAssembly canonical NaN of the given width.
(macro (nan_canon w)
    (conv_to w
        (switch w
            (32 #x000000007fc00000)
            (64 #x7ff8000000000000)
        )
    )
)

; NaN propagation with zero inputs.
;
; The CLIF semantics (inherited from WebAssembly) only requires a NaN payload
; with the top bit set. Our specification is a refinement, selecting the
; positive canonical NaN.
(macro (nans0 w) (nan_canon! w))

; NaN propagation with one input.
;
; The CLIF semantics (inherited from WebAssembly) requires that a canonical NaN
; input is preserved, while any other NaN is mapped to any arithmetic NaN (which
; has the top fraction bit set).  Our chosen refinement is to return the NaN
; input with the top fraction bit or-ed in: this both preserves the canonical
; NaN and turns any other NaN into an arithmetic NaN.
(macro (nans1 x) (if (fp.isNaN x) (bvor x (fp_topfrac_bit_set! (widthof x))) (nans0! (widthof x))))

; NaN propagation with two inputs.
;
; The CLIF semantics (inherited from WebAssembly) requires that if both inputs
; are canonical then the output must be. Otherwise the output must be an
; arithmetic NaN. Our chosen refinement is to apply single-input NaN propagation
; to the first input if it's a NaN, otherwise to the second input if it's a NaN,
; and fallback to returning the canonical NaN.
(macro (nans2 x y) (if (fp.isNaN x) (nans1! x) (if (fp.isNaN y) (nans1! y) (nans0! (widthof x)))))

; NaN negation.
;
; The CLIF semantics (inherited from WebAssembly) requires that negating a NaN
; flips the sign bit (rather than returning a nondeterministic NaN).
(macro (nan_neg x)
    (conv_to (widthof x)
        (bvxor x (fp_sign_bit_set! (widthof x)))))

; fcmp: floating-point compare.
(spec (fcmp c x y)
    (provide
        ;; Restrict to operations used from Wasm for now
        (or (= c (FloatCC.Equal))
            (= c (FloatCC.NotEqual))
            (= c (FloatCC.LessThan))
            (= c (FloatCC.GreaterThan))
            (= c (FloatCC.LessThanOrEqual))
            (= c (FloatCC.GreaterThanOrEqual)))
        (= result
            (if
                (match c
                    ((Equal) (fp.eq x y))
                    ((NotEqual) (fp.ne x y))
                    ((LessThan) (fp.lt x y))
                    ((GreaterThan) (fp.gt x y))
                    ((LessThanOrEqual) (fp.le x y))
                    ((GreaterThanOrEqual) (fp.ge x y))
                )
                #x01
                #x00
            )
        )
    )
)
(instantiate fcmp
    ((args (named FloatCC) (bv 32) (bv 32)) (ret (bv 8)))
    ((args (named FloatCC) (bv 64) (bv 64)) (ret (bv 8)))
)

; fadd: floating-point addition.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fadd x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if both z1 and z2 are infinities of opposite signs, then return an element of nans{}.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_opposite_sign! x y))
                (nans0! (widthof x))
            ; Else if both z1 and z2 are infinities of equal sign, then return that infinity.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_equal_sign! x y))
                x
            ; Else if either z1 or z2 is an infinity, then return that infinity.
            (if (fp.isInfinite x)
                x
            (if (fp.isInfinite y)
                y
            ; Else if both z1 and z2 are zeroes of opposite sign, then return positive zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_opposite_sign! x y))
                (fp.+zero (widthof x))
            ; Else if both z1 and z2 are zeroes of equal sign, then return that zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_equal_sign! x y))
                x
            ; Else if either z1 or z2 is a zero, then return the other operand.
            (if (fp.isZero x)
                y
            (if (fp.isZero y)
                x
            ; Else if both z1 and z2 are values with the same magnitude but opposite signs, then return positive zero.
            (if (and (= (fp_magnitude! x) (fp_magnitude! y)) (fp_opposite_sign! x y))
                (fp.+zero (widthof x))
            ; Else return the result of adding z1 and z2, rounded to the nearest representable value.
                (fp.add x y)
            ))))))))))
        )
    )
)
(instantiate fadd
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

; fsub: floating-point subtraction.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fsub x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if both z1 and z2 are infinities of equal sign, then return an element of nans{}.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_equal_sign! x y))
                (nans0! (widthof x))
            ; Else if both z1 and z2 are infinities of opposite signs, then return z1.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_opposite_sign! x y))
                x
            ; Else if z1 is an infinity, then return that infinity.
            (if (fp.isInfinite x)
                x
            ; Else if z2 is an infinity, then return that infinity negated.
            (if (fp.isInfinite y)
                (fp.neg y)
            ; Else if both z1 and z2 are zeroes of equal sign, then return positive zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_equal_sign! x y))
                (fp.+zero (widthof x))
            ; Else if both z1 and z2 are zeroes of opposite sign, then return z1.
            (if (and (fp.isZero x) (fp.isZero y) (fp_opposite_sign! x y))
                x
            ; Else if z2 is a zero, then return z1.
            (if (fp.isZero y)
                x
            ; Else if z1 is a zero, then return z2 negated.
            (if (fp.isZero x)
                (fp.neg y)
            ; Else if both z1 and z2 are the same value, then return positive zero.
            (if (and (= (fp_magnitude! x) (fp_magnitude! y)) (fp_equal_sign! x y))
                (fp.+zero (widthof x))
            ; Else return the result of subtracting z2 from z1, rounded to the nearest representable value.
                (fp.sub x y)
            ))))))))))
        )
    )
)
(instantiate fsub
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

; fmul: floating-point multiplication.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fmul x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if one of z1 and z2 is a zero and the other an infinity, then return an element of nans{}.
            (if (and (fp.isZero x) (fp.isInfinite y))
                (nans0! (widthof x))
            (if (and (fp.isInfinite x) (fp.isZero y))
                (nans0! (widthof x))
            ; Else if both z1 and z2 are infinities of equal sign, then return an element of nans{}.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_equal_sign! x y))
                (fp.+oo (widthof x))
            ; Else if both z1 and z2 are infinities of opposite signs, then return z1.
            (if (and (fp.isInfinite x) (fp.isInfinite y) (fp_opposite_sign! x y))
                (fp.-oo (widthof x))
            ; Else if either z1 or z2 is an infinity and the other a value with equal sign, then return positive infinity.
            (if (and (fp.isInfinite x) (fp_equal_sign! x y))
                (fp.+oo (widthof x))
            (if (and (fp.isInfinite y) (fp_equal_sign! x y))
                (fp.+oo (widthof x))
            ; Else if either z1 or z2 is an infinity and the other a value with opposite sign, then return negative infinity.
            (if (and (fp.isInfinite x) (fp_opposite_sign! x y))
                (fp.-oo (widthof x))
            (if (and (fp.isInfinite y) (fp_opposite_sign! x y))
                (fp.-oo (widthof x))
            ; Else if both z1 and z2 are zeroes of equal sign, then return positive zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_equal_sign! x y))
                (fp.+zero (widthof x))
            ; Else if both z1 and z2 are zeroes of opposite sign, then return negative zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_opposite_sign! x y))
                (fp.-zero (widthof x))
            ; Else return the result of multiplying z1 and z2, rounded to the nearest representable value.
                (fp.mul x y)
            )))))))))))
        )
    )
)
(instantiate fmul
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

; fdiv: floating-point division.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fdiv x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if both z1 and z2 are infinities, then return an element of nans{}.
            (if (and (fp.isInfinite x) (fp.isInfinite y))
                (nans0! (widthof x))
            ; Else if both z1 and z2 are zeroes, then return an element of nans{z1,z2}.
            (if (and (fp.isZero x) (fp.isZero y))
                (nans2! x y)
            ; Else if z1 is an infinity and z2 a value with equal sign, then return positive infinity.
            (if (and (fp.isInfinite x) (fp_equal_sign! x y))
                (fp.+oo (widthof x))
            ; Else if z1 is an infinity and z2 a value with opposite sign, then return negative infinity.
            (if (and (fp.isInfinite x) (fp_opposite_sign! x y))
                (fp.-oo (widthof x))
            ; Else if z2 is an infinity and z1 a value with equal sign, then return positive zero.
            (if (and (fp.isInfinite y) (fp_equal_sign! x y))
                (fp.+zero (widthof x))
            ; Else if z2 is an infinity and z1 a value with opposite sign, then return negative zero.
            (if (and (fp.isInfinite y) (fp_opposite_sign! x y))
                (fp.-zero (widthof x))
            ; Else if z1 is a zero and z2 a value with equal sign, then return positive zero.
            (if (and (fp.isZero x) (fp_equal_sign! x y))
                (fp.+zero (widthof x))
            ; Else if z1 is a zero and z2 a value with opposite sign, then return negative zero.
            (if (and (fp.isZero x) (fp_opposite_sign! x y))
                (fp.-zero (widthof x))
            ; Else if z2 is a zero and z1 a value with equal sign, then return positive infinity.
            (if (and (fp.isZero y) (fp_equal_sign! x y))
                (fp.+oo (widthof x))
            ; Else if z2 is a zero and z1 a value with opposite sign, then return negative infinity.
            (if (and (fp.isZero y) (fp_opposite_sign! x y))
                (fp.-oo (widthof x))
            ; Else return the result of dividing z1 by z2, rounded to the nearest representable value.
                (fp.div x y)
            )))))))))))
        )
    )
)
(instantiate fdiv
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)


; fmin: floating-point minimum.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fmin x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if either z1 or z2 is a negative infinity, then return negative infinity.
            (if (or (and (fp.isInfinite x) (fp.isNegative x)) (and (fp.isInfinite y) (fp.isNegative y)))
                (fp.-oo (widthof x))
            ; Else if either z1 or z2 is a positive infinity, then return the other value.
            (if (and (fp.isInfinite x) (fp.isPositive x))
                y
            (if (and (fp.isInfinite y) (fp.isPositive y))
                x
            ; Else if both z1 and z2 are zeroes of opposite signs, then return negative zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_opposite_sign! x y))
                (fp.-zero (widthof x))
            ; Else return the smaller value of z1 and z2.
                (fp.min x y)
            )))))
        )
    )
)
(instantiate fmin
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

; fmax: floating-point minimum.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fmax x y)
    (provide
        (= result
            ; If either z1 or z2 is a NaN, then return an element of nans{z1,z2}.
            (if (or (fp.isNaN x) (fp.isNaN y))
                (nans2! x y)
            ; Else if either z1 or z2 is a positive infinity, then return positive infinity.
            (if (or (and (fp.isInfinite x) (fp.isPositive x)) (and (fp.isInfinite y) (fp.isPositive y)))
                (fp.+oo (widthof x))
            ; Else if either z1 or z2 is a negative infinity, then return the other value.
            (if (and (fp.isInfinite x) (fp.isNegative x))
                y
            (if (and (fp.isInfinite y) (fp.isNegative y))
                x
            ; Else if both z1 and z2 are zeroes of opposite signs, then return positive zero.
            (if (and (fp.isZero x) (fp.isZero y) (fp_opposite_sign! x y))
                (fp.+zero (widthof x))
            ; Else return the smaller value of z1 and z2.
                (fp.max x y)
            )))))
        )
    )
)
(instantiate fmax
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)


; fabs: floating-point absolute value.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fabs x)
    (provide
        (= result
            ; If z is a NaN, then return z with positive sign.
            (if (fp.isNaN x)
                (bvand x (bvnot (fp_sign_bit_set! (widthof x))))
            ; Else if z is an infinity, then return positive infinity.
            (if (fp.isInfinite x)
                (fp.+oo (widthof x))
            ; Else if z is a zero, then return positive zero.
            (if (fp.isZero x)
                (fp.+zero (widthof x))
            ; Else if z is a positive value, then return z.
            (if (fp.isPositive x)
                x
            ; Else return z negated.
                (fp.neg x)
            ))))
        )
    )
)
(instantiate fabs
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)


; fneg: floating-point negation.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (fneg x)
    (provide
        (= result
            ; If z is a NaN, then return z with negated sign.
            (if (fp.isNaN x)
                (nan_neg! x)
            ; Else if z is an infinity, then return that infinity negated.
            ; Else if z is a zero, then return that zero negated.
            ; Else return z negated.
                (fp.neg x)) ; Remaining cases of the spec handled by SMT fp.neg
        )
    )
)
(instantiate fneg
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)


; sqrt: floating-point square root.
;
; Specification derived from WebAssembly Specification prose (Floating Point Numerics, section 4.3.3).
(spec (sqrt x)
    (provide
        (= result
            ; If z is a NaN, then return an element of nans{z}.
            (if (fp.isNaN x)
                (nans1! x)
            ; Else if z is negative infinity, then return an element of nans{}.
            (if (and (fp.isInfinite x) (fp.isNegative x))
                (nans0! (widthof x))
            ; Else if z is positive infinity, then return positive infinity.
            (if (and (fp.isInfinite x) (fp.isPositive x))
                (fp.+oo (widthof x))
            ; Else if z is a zero, then return that zero.
            (if (fp.isZero x)
                x
            ; Else if z has a negative sign, then return an element of nans{}.
            (if (fp.isNegative x)
                (nans0! (widthof x))
            ; Else return the square root of z.
                (fp.sqrt x)
            )))))
        )
    )
)
(instantiate sqrt
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)

(spec (bitcast flags x)
    (provide (= result x))
)
; I32ReinterpretF32
; I64ReinterpretF64
; F32ReinterpretI32
; F64ReinterpretI64
(instantiate bitcast
    ((args (named MemFlags) (bv 32)) (ret (bv 32)))
    ((args (named MemFlags) (bv 64)) (ret (bv 64)))
)

(spec (fcvt_from_uint x)
    (provide
        (let ((N (widthof result)))
            (= result (to_fp_unsigned N (conv_to N (zero_ext 64 x))))))
)
(instantiate fcvt_from_uint
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 32)) (ret (bv 64)))
    ((args (bv 64)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64))))
