use std::io::Write;
use std::path::{Path, PathBuf};
use std::{io, vec};

use anyhow::Result;
use clap::Parser as ClapParser;

use cranelift_isle::{
    ast::{Attr, AttrKind, AttrTarget, Def},
    printer,
};
use cranelift_isle_veri_aslp::client::Client;
use cranelift_isle_veri_isaspec::{builder::Builder, instructions, spec::spec_ident};

#[derive(ClapParser)]
#[command(version, about)]
struct Args {
    /// Server URL
    #[arg(long = "server", required = true)]
    server: String,

    // Output directory.
    #[arg(long, required = true)]
    output: PathBuf,

    // Maximum line width.
    #[arg(long, default_value = "120")]
    width: usize,

    /// Print debugging output (repeat for more detail)
    #[arg(short = 'd', long = "debug", action = clap::ArgAction::Count)]
    debug_level: u8,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Setup tracing output.
    tracing_subscriber::fmt()
        .with_writer(io::stderr)
        .with_timer(tracing_subscriber::fmt::time::uptime())
        .with_level(true)
        .with_target(false)
        .with_max_level(match args.debug_level {
            0 => tracing::Level::WARN,
            1 => tracing::Level::INFO,
            2 => tracing::Level::DEBUG,
            _ => tracing::Level::TRACE,
        })
        .init();

    // ASLp client.
    let http_client = reqwest::blocking::Client::new();
    let client = Client::new(&http_client, args.server)?;

    // Conversion.
    let file_configs = instructions::define()?;
    for file_config in file_configs {
        // Generate specs.
        let mut defs = Vec::new();
        for spec_config in file_config.specs {
            // Tag the term as generated.
            defs.push(Def::Attr(generated_attribute(&spec_config.term)));
            // Build and output the spec.
            let builder = Builder::new(spec_config, &client);
            let def = builder.build()?;
            defs.push(def);
        }

        // Output.
        let path = args.output.join(file_config.name);
        write_spec(&path, &defs, args.width)?;
    }

    Ok(())
}

fn generated_attribute(term: &str) -> Attr {
    Attr {
        target: AttrTarget::Term(spec_ident(term.to_string())),
        kinds: vec![AttrKind::Tag(spec_ident("isaspec_generated".to_string()))],
        pos: Default::default(),
    }
}

fn write_spec(path: &Path, defs: &Vec<Def>, width: usize) -> Result<()> {
    let mut output = std::fs::File::create(path)?;

    // Code generation warning.
    writeln!(output, ";; GENERATED BY `isaspec`. DO NOT EDIT!!!")?;
    writeln!(output)?;

    // Format with ISLE printer.
    printer::print(defs, width, &mut output)?;

    Ok(())
}
